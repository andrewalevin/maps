<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Query terrain elevation</title>
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
    <link href="https://api.mapbox.com/mapbox-gl-js/v3.2.0/mapbox-gl.css" rel="stylesheet">
    <script src="https://api.mapbox.com/mapbox-gl-js/v3.2.0/mapbox-gl.js"></script>

    <script src="https://andrewalevin.github.io/maps/dev/routes-zvenigorod.js-"></script>


    <script src="https://andrewalevin.github.io/maps/notebook/data-output/zvenigorod-camera-1712171569.js"></script>


    <script src="/Users/andrewlevin/Desktop/maps/notebook/data-output/mskappr-camera.js-"></script>

    <script src="/Users/andrewlevin/Desktop/maps/notebook/data-output/mskappr-target.js-"></script>

    <script src="polushkino-v5-config.js"></script>




    <script src="/Users/andrewlevin/Desktop/maps/notebook/data-output/mskappr1one-camera.js-"></script>
    <script src="/Users/andrewlevin/Desktop/maps/notebook/data-output/mskappr1one-target.js-"></script>


    <script src="/Users/andrewlevin/Desktop/maps/notebook/data-output/stage2.js"></script>

    <style>
        body {
            margin: 0;
            padding: 0;
        }
        
        #map {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100%;
        }
    </style>
    <style>
        .mapboxgl-popup-content,
        .mapboxgl-popup-tip {
            opacity: 0.8;
        }
        
        .mapboxgl-popup-content {
            position: relative;
            border-radius: 3px;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.10);
            padding: 8px;
            pointer-events: auto;
        }
        
        #pauseButton {
            position: absolute;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px;
            z-index: 1;
            color: #111;
            background-color: rgb(128 128 128 / 50%);
            padding: .75rem;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 200;
            color: #222;
            background-color: rgb(231 231 231 / 10%);
            font-size: 1rem;
            font-weight: 100;
            min-width: 6rem;
            backdrop-filter: blur(1rem);
        }
    </style>
</head>

<body>
    <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
    <div id="map"></div>

    <button id="pauseButton">Pause</button>

    <script>
        console.log('üöÄ Start Script');
        console.log('üöÄ stage', stage2);
        console.log('');

        //mapboxgl.accessToken = 'pk.eyJ1IjoiYW5kcmV3bGV2aW4iLCJhIjoiY2t5ZXM5c3cyMWJxYjJvcGJycmw0dGlyeSJ9.9QfCmimkyYicpprraBc-XQ';
        mapboxgl.accessToken = 'pk.eyJ1IjoiYW5kcmV3bGV2aW4iLCJhIjoiY2t5ZXM5c3cyMWJxYjJvcGJycmw0dGlyeSJ9.9QfCmimkyYicpprraBc-XQ';

        let geojson = '';
        //geojson = 'https://docs.mapbox.com/mapbox-gl-js/assets/route-pin.geojson';


        geojson = 'https://andrewalevin.github.io/maps/dev/route-pin.geojson';

        geojson = 'https://andrewalevin.github.io/maps/dev/gigerevo.geojson';
        geojson = 'https://andrewalevin.github.io/maps/dev/gigerevo-reverted.geojson';
        geojson = 'https://andrewalevin.github.io/maps/notebook/data-output/zvenigorod-route-1712096945.geojson';



        var isPaused = false;

        var pauseButton = document.getElementById('pauseButton');
        pauseButton.addEventListener('click', function() {
            isPaused = !isPaused;
            if (isPaused) {
                console.log('üß≤ now Pause');
                pauseButton.textContent = 'Play';
            } else {
                console.log('üß≤ now Play');
                pauseButton.textContent = 'Pause';
            }
        });


        (async() => {
            const map = new mapboxgl.Map({
                container: 'map',
                zoom: zoomMap,
                center: centerMap,
                pitch: pitchMap,
                bearing: bearingMap,
                style: styleMap,
                interactive: false,
                hash: false
            });



            // Start downloading the route data, and wait for map load to occur in parallel
            const [pinRouteGeojson] = await Promise.all([
                fetch(
                    geojson
                ).then((response) => response.json()),
                map.once('style.load')
            ]);

            // Set custom fog
            map.setFog({
                'range': rangeFog,
                'color': '#def',
                'high-color': '#def',
                'space-color': '#def'
            });

            // Add terrain source, with slight exaggeration
            map.addSource('mapbox-dem', {
                'type': 'raster-dem',
                'url': 'mapbox://mapbox.terrain-rgb',
                'tileSize': 512,
                'maxzoom': 14
            });
            map.setTerrain({
                'source': 'mapbox-dem',
                'exaggeration': 1.5
            });

            const pinRoute = pinRouteGeojson.features[0].geometry.coordinates;

            // Create the marker and popup that will display the elevation queries
            const popup = new mapboxgl.Popup({
                closeButton: false
            });
            const marker = new mapboxgl.Marker({
                    color: 'red',
                    scale: 0.8,
                    draggable: false,
                    pitchAlignment: 'auto',
                    rotationAlignment: 'auto'
                })
                .setLngLat(pinRoute[0])
                .setPopup(popup)
                .addTo(map)
                .togglePopup();

            // Add a line feature and layer. This feature will get updated as we progress the animation
            map.addSource('line', {
                type: 'geojson',
                // Line metrics is required to use the 'line-progress' property
                lineMetrics: true,
                data: pinRouteGeojson
            });
            map.addLayer({
                type: 'line',
                source: 'line',
                id: 'line',
                paint: {
                    'line-color': 'rgba(0,0,0,0)',
                    'line-width': 5
                },
                layout: {
                    'line-cap': 'round',
                    'line-join': 'round'
                }
            });

            await map.once('idle');

            // The total animation duration, in milliseconds
            //const animationDuration = 50000;

            // Use the https://turfjs.org/ library to calculate line distances and
            // sample the line at a given percentage with the turf.along function.
            const path = turf.lineString(pinRoute);
            // Get the total line distance
            const pathDistance = turf.lineDistance(path);


            let totalDistance = 0;
            let lastPoint = null;


            // ZVENIGOROD-CAMERA
            //const targetRoute = routes.target;
            //const cameraRoute = routes.camera;


            const targetRoute = stage2.target.route;
            const cameraRoute = stage2.camera.route;

            const routeDistance = turf.lineDistance(turf.lineString(targetRoute));
            const cameraRouteDistance = turf.lineDistance(turf.lineString(cameraRoute));

            console.log('ü•¶ routeDistance: ', routeDistance);

            let lastTime = 0;
            let totalTime = 0;

            function frame(time) {



                if (!isPaused) {
                    totalTime += (time - lastTime);
                    const phase = totalTime / animationDuration;
                    if (phase > 1) {
                        return;
                    }
                    console.log('üêù Time: ', time, 'phase: ', phase);


                    // Get the new latitude and longitude by sampling along the path
                    const alongPath = turf.along(path, pathDistance * phase)
                        .geometry.coordinates;
                    const lngLat = {
                        lng: alongPath[0],
                        lat: alongPath[1]
                    };

                    // Sample the terrain elevation. We round to an integer value to
                    // prevent showing a lot of digits during the animation
                    const elevation = Math.floor(
                        // Do not use terrain exaggeration to get actual meter values
                        map.queryTerrainElevation(lngLat, {
                            exaggerated: false
                        })
                    );

                    if (lastPoint)
                        totalDistance += turf.distance(turf.point(lastPoint), turf.point(alongPath), {
                            units: 'kilometers'
                        });
                    lastPoint = alongPath;



                    // Reduce the visible length of the line by using a line-gradient to cutoff the line
                    // phase is a value between 0 and 1 that reprents the progress of the animation
                    map.setPaintProperty('line', 'line-gradient', [
                        'step', ['line-progress'],
                        'red',
                        phase,
                        'rgba(255, 0, 0, 0)'
                    ]);

                    // Rotate the camera at a slightly lower speed to give some parallax effect in the background
                    //const rotation = 150 - phase * 40.0;
                    //map.setBearing(rotation % 360 + 90);


                    // CAMERA

                    const alongRoute = turf.along(
                        turf.lineString(targetRoute),
                        routeDistance * phase
                    ).geometry.coordinates;

                    const alongCamera = turf.along(
                        turf.lineString(cameraRoute),
                        cameraRouteDistance * phase
                    ).geometry.coordinates;


                    const camera = map.getFreeCameraOptions();

                    let cameraAltitude = window[stage2.camera.altitude_function](
                        phase, stage2.camera.altitude[0], stage2.camera.altitude[1]);
                    console.log('üèî cameraAltitude: ', cameraAltitude);

                    // set the position and altitude of the camera
                    camera.position = mapboxgl.MercatorCoordinate.fromLngLat({
                            lng: alongCamera[0],
                            lat: alongCamera[1]
                        },
                        cameraAltitude
                    );

                    // tell the camera to look at a point along the route
                    camera.lookAtPoint({
                        lng: alongRoute[0],
                        lat: alongRoute[1],
                    });


                    const dist = turf.distance(alongCamera, alongRoute);
                    const alt = cameraAltitude / 1000;
                    const tn = Math.atan(dist / alt);
                    const grad = tn * 57.2958;
                    console.log('üìê dist', dist, ' alt: ', alt, ' tn: ', tn, ' grad: ', grad);
                    camera.setPitchBearing(grad, 0);


                    console.log('Camera: ', camera);


                    map.setFreeCameraOptions(camera);

                    // Update the popup altitude value and marker location
                    popup.setHTML(Math.trunc(totalDistance) + ' km<br/>');
                    //console.log(lngLat);
                    marker.setLngLat(lngLat);

                }

                lastTime = time;
                window.requestAnimationFrame(frame);

            }
            window.requestAnimationFrame(frame);


        })();
    </script>

</body>

</html>